# 리팩터링 원칙

1장에서는 실제 코드를 리팩토링하며 기법중 몇가지를 소개하였다.  
2장에서는 리팩터링의 원칙에 대해서 설명하고 있다.
  
만약 아래와 같은 고민을 해본적이 있다면 꼭 읽어봐야할 장이라고 생각합니다.  
- 리팩터링이란?
- 리팩터링을 왜 해야 하는가?
- 언제 리팩터링을 해야할까?
- 언제 리팩터링을 해야하지 말아야 할까?
- 리팩터링은 자주하는것이 좋은지 아니면 나중에 몰아서하는게 좋을지?
- 리팩터링시 고려해야할 문제들은 무엇이 있을까?
- 성능이 나빠질거라 예상되더라도 리팩터링이 필요할까?
  
## 누구나 알고 있는 사실
리팩터링을 한다면 그 이유는 무엇일까?
- 리팩터링을 하면 소프트웨어 설계가 좋아진다
- 소프트웨어를 이해하기 쉬워진다.
- 버그를 쉽게 찾을 수 있다.
- 프로그래밍 속도를 높일 수 있다.
- 코드의 가독성이 좋아진다.
  
리팩터링은 코드의 설계와 로직에 대한 이해가 바탕이 되지않고는 진행하기 어렵다. 리팩터링을 하다가 또다른 버그가 생길 수도있고 잘 돌아가던 기능이 망가지는 경험을 누구나 한번씩을 해보지 않았을까 싶다.
  
위의 리팩터링을 하는 이유는 좀더 직관적으로 말하자면 불편한코드 이해하기 어려운코드 복잡한 코드, 비대해진 코드 즉 책에서 말하는 악취가 나는 코드가 보인다면 이걸 바꿔버리고 싶다는 욕구라고 할수도 있을것같다.
  
> 누군가 리팩터링 하다가 코드가 꺠져서 며칠이나 고생했다 라고 한다면 그것을 리팩터링 한것이 아니다.
  
## 그렇다면 언제 리팩터링 해야할까?
> 리팩터링 하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다.
  
이때 리팩터링을 단계를 거쳐서 진행하는것이 좋다.
1. 준비를위한 리팩터링
2. 이해를 위한 리팩터링
  
### 쓰레기 줍기 리팩터링
저자는 기능추가나 다른 작업을 하는 중에도 중간중간 리팩토링을 진행한다고 한다. 그러나 애매한 상황을 마주할 수도 있다. 보통은 짧은시간내에 리팩터링을 진행한다. 그러나 원래 하려던 작업과 관련없는 리팩터링 작업에 오랜시간을 투자해야할 경우가 발생할 수도있다.  
그렇다고 그냥 놔두기엔 쓰레기처럼 나중에 치우려고 방치하다간 계속 쓰레기가 쌓일수도 있다.  
이떄 할수있는게 쓰레기 줍기 리팩터링이다. 시간이 적게걸리는 부분만이라도 조금씩 리팩터링을 진행해 두는것이 좋다. 이때 중요한점은 각각의 작은 단계가 코드를 깨뜨리지 않아야 한다는 사실이다.
  
이렇게 작업을 잘게 나누어 몇달에 걸쳐 진행하더라도 그 사이 한순간이라도 코드가 깨지지 않을 수 있다.
  
준비를위한 리팩터링, 이해를위한 리팩터링, 쓰레기줍기 리팩터링 은 모두 기회가 될때만 진행한다. 리팩터링은 일정을 따로 잡아두지않고 프로그래밍 과정에서 자연스럽게 녹아들게 진행한다.
  
> 무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고 그런 다음 쉽게 수정하자.
  
## 리팩터링 하지 말아야 할때
- 외부 API 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 둔다.
- 리팩터링보다 처음부터 새로 작성하는것이 쉬울때도 리팩터링 하지 않는다.
  
그러나 이런 결정을 내리는것은 쉽지 않다. 직접 리팩터링을 해보기전엔 어느쪽이 쉬운지 확실하기가 어렵다. 이를 판단하려면 뛰어난 판단력과 경험이 뒷받침 되어야 한다.

## 리팩터링 시 고려할 문제
### 1. 새 기능 개발 속도 저하
> 리팩터링의 궁극적인 목적은 개발 속도를 높여서 더 적은 노력으로 더 많은 가치를 창출하는 것이다.
  
사람들이 빠지기 쉬운 가장 위험한 오류는 리팩터링을 클린코드나 바람직한 엔지니어링 습관 처엄 도덕적인 이유로 정당화 하는것  
리팩터링의 본질은 코드베이스를 예쁘게 꾸미는것이 아니다. 오로지 경제적인 이유로 하는것이다. 리팩터링은 개발 기간을 단축하고자 하는것이다.  기능 추가 시간을 줄이고 버그 수정 시간을 줄여준다.
  
### 2.  코드 소유권
코드 소유권을 나눠서 특정 담당자만 코드를 수정하거나 접근 권한을 갖도록 하는곳은 많지 않을것같아서 해당 내용은 패스
  
사내 모든 프로젝트에 대해서 모든 개발자는 접근이 가능하고 기능 개발 및 코드추가 유지보수가 가능하다.
  
### 3. 브랜치
흔히 볼 수 있는 방식은 버전 관리 시스템을 사용하여 팀원마다 기능별 브랜치로 작업을 하다가 배포 브랜치에 통합하여 팀원과 공유하는 방식을 취한다.   
즉 어떤 기능을 한 브랜치 안에서 구현해놓고 프로덕션 버전으로 릴리즈할때가 되어야 배포 브랜치에 통합하게 된다.  
장점으로는 완료되지 않은 작업이 배포 브랜치에 섞이지 않고 기능 추가에 따라 버전을 명확히 나누고 문제가 생기더라도 쉽게 이전상태로 되돌릴 수 있다.  
나도 이렇게 생각했고 위와같은 브랜치 관리 방식을 팀에 제안하여 현재 적용해서 활용하고 있다.
  
하지만 최근 계속해서 찜찜함 불편함 기시감을 느끼는데 그걸 이 책에서 리팩터링 관점에서 명확하게 단점에 대해서 설명해 주고 있다.
  
독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 통합하기 어려워 진다.
  
위에서 리팩터링하기 가장 좋은 시점은 기능을 추가하기 전이다라고 책에서 서술했는데 이러한 기능개발 방식은 리팩터링을 자주 쉽게 여러변 할 수 없는 환경을 만들어 버린다.
  
리팩터링을 하다보면 결국 공통함수 또는 더 깊은 컴포넌트까지 손을 대야하는 상황이 생길 수 있는데 나중에 통합 작업을 진행했을때 어떤 기능은 제대로 동작하지 않을 가능성이 매우 높다. 그래서 기능별 브랜치의 통합 주기를 매우 짧게 가져가야 한다고 주장한다. 그 짧은 기간은 하루에 한번이 기준이다.  
이러한 방식을 지속적 통합 또는 트렁크 기반 개발이라고 한다.
  
다만 이렇게 짧게 통합하는 과정을 가져가려면 리팩터링의 과정이 진행되더라도 결과물은 동일하게 동작됨을 보장할 수 있어야 한다. 그리고 이러한 보장을 얻으려면 테스트코드가 작성되어 있어야 한다.
  

### 4. 테스팅
리팩터링의 두드러진 특성은 프로그램의 겉보기 동작은 똑같이 유지된다는 것이다. 절차를 지켜 제대로 리팩터링 하면 동작이 깨지지 않아야 한다.
  
핵심은 오류를 재빨리 잡는데에 있다. 이렇게 하려면 테스트가 필요하다. 그리고 수시로 테스트할수 있어 테스트에대한 부담이 없어야 한다.
  
### 5. 레거시 코드
결론을 말하자면 레거시코드를 쉽게 리팩터링 할 수 있는 방법은 없다. 테스트를 진행하려면 테스트를 염두해두고 코드가 작성되어 있어야 하는데 테스트가 갖춰진 레거시코드라면 리팩터링을 두려워할 필요가 없다. 하지만 현실은 그렇지 않기때문에 이러한 경우는 약간의 위험성을 감수하더라도 리팩터링을 진행해야한다.  
  
이를 좀더 쉽게 빠르게 해결하는 방법은 테스트코드를 작성하는 방법이고 그 이후에 리팩터링을 진행하는것인데 둘다 매우 어려운 과정이다.
  
## 리팩터링과 소프트웨어 개발 프로세스
리팩터링의 첫 번째 토대는 자가 테스트 코드  
그리고 지속적 통합을 통해 팀원 각자가 수행한 리팩터링 결과를 빠르게 동료와 공유할 수 있다.  
이러한 과정은 강력한 상승효과를 발휘한다.  

